ANÁLISIS COMPARATIVO: DIAGRAMA DE SECUENCIA VS CÓDIGO
Proyecto: PPAI_Copia
Fecha: 2025-10-16

Resumen del Caso de Uso
- Nombre: Registrar Resultado de Revisión Manual de Evento Sísmico
- Actor Principal: Empleado Revisor
- Descripción breve: El sistema permite al revisor seleccionar un evento sismológico autodetectado/pendiente, bloquearlo para revisión, visualizar sus datos, y registrar un resultado (rechazar/confirmar/solicitar experto), dejando traza en los cambios de estado.

Estructura del Proyecto (carpetas relevantes)
- interface/PantallaRevisionEventoSismico.py (Boundary)
- controllers/GestorRevisionEventoSismico.py (Control)
- entities/* (Entity): EventoSismico, Estado, CambioEstado, SerieTemporal, MuestraSismica, DetalleMuestraSismica, AlcanceSismo, ClasificacionSismo, OrigenDeGeneracion, Sismografo, EstacionSismologica, Usuario, Empleado, Sesion
- main.py (Flask endpoints)

SECUENCIA Y COMPARACIÓN 1 A 1

FASE 1: INICIO DEL CASO DE USO
1. Pantalla.opcRegistrarResultadoRevisionManual() -> OK (método presente)
2. Pantalla.habilitarPantalla() -> OK
3. new GestorRevisionEventoSismico(Pantalla) -> OK
4. Gestor.opcRegistrarResultadoRevisionManual() -> OK
5. Gestor.obtenerUsuarioLogueado() -> OK
6. Sesion.getUsuarioActivo() -> OK
7. Usuario.getEmpleado() -> OK

FASE 2: BÚSQUEDA Y FILTRADO DE EVENTOS
8. Gestor.buscarEventosAutoDetectados() -> OK
9. Loop eventos -> OK (recorre eventos_mock)
10. Evento.estaAutoDetectado() -> OK
11. Estado.esAutoDetectado() -> OK
12. Evento.estaPendienteDeRevision() -> OK
13. Estado.esPendienteDeRevision() -> OK
14. Gestor.ordenarPorFechaYHora() -> OK
15. Pantalla.mostrarYSolicitarSeleccionEvento() -> OK

FASE 3: SELECCIÓN Y BLOQUEO DE EVENTO
16. Pantalla.tomarSeleccionEvento(indice) -> OK
17. Gestor.tomarSeleccionEvento(evento) -> OK
18. Gestor.bloquearEventoSismico() -> OK
19. Loop estados -> OK (recorre estados_mock)
20. Estado.esAmbito() -> CÓDIGO: esAmbitoEventoSismico() (diferencia de nombre)
21. Estado.esBloqueadoEnRevision() -> OK
22. Evento.obtenerEstadoActual() -> OK
23. CambioEstado.esEstadoActual() -> OK
24. Gestor.calcularFechaHoraActual() -> OK
25. Evento.setEstadoActual(Estado) -> OK
26. Evento.bloquearEnRevision(Estado, CambioEstado, fecha, usuario) -> OK
27. CambioEstado.setFechaHoraFin() -> OK
28. CambioEstado.setResponsableInspeccion() -> OK
29. new CambioEstado(fecha, estado, usuario) -> OK

FASE 4: OBTENCIÓN DE DATOS DEL EVENTO
30. Gestor.buscarDatosEventoSismico() -> OK
31. Evento.obtenerDatosEvento() -> OK
32. AlcanceSismo.getNombre() -> OK
33. OrigenDeGeneracion.getNombre() -> OK
34. ClasificacionSismo.getNombre() -> OK

FASE 5: DATOS POR ESTACIÓN / SERIES
35. Gestor.buscarDatosSeriePorEstacion() -> CÓDIGO: buscarDatosSeriesPorEstacion() (plural)
36. Loop series temporales -> OK
37. SerieTemporal.obtenerNombreEstacion(sismografos) -> OK
38. Sismografo.esTuSerie(serie) -> OK
39. EstacionSismologica.getNombre() -> OK
40. Loop muestras -> OK
41. MuestraSismica.getFechaHoraMuestra() -> OK
42. Loop detalles -> OK
43. DetalleMuestraSismica.getDatos() -> OK
44. TipoDeDato.esTuDenominacion("Longitud de onda"/etc) -> OK
45. DetalleMuestraSismica.getValor() -> OK

FASE 6: CU18 Y MOSTRAR DATOS
46. Gestor.llamarCU18() -> OK (simulado por print)
47. <<include>> CU18 Generar sismograma -> OK (simulado)
48. Pantalla.mostrarDatosEventoSismico() -> CÓDIGO: mostrarDatosEventosSismicos() (plural)

FASE 7: INTERACCIONES OPCIONALES
49. Pantalla.tomarSeleccionMapa() -> OK
50. Pantalla.tomarSeleccionModificar() -> OK

FASE 8: RECHAZAR EVENTO (ALTERNATIVO)
51. Pantalla.opRechazarEvento() -> OK
52. Gestor.opRecharEvento() -> CÓDIGO: opRechazarEvento(accion) (typo en diagrama)
53. Gestor.validarAccionSeleccionada() -> OK
54. Evento.validarDatos() -> OK
55. Gestor.rechazarEventoSismico() -> OK
56. Loop estados -> OK
57. Estado.esAmbito() -> CÓDIGO: esAmbitoEventoSismico() (diferencia de nombre)
58. Estado.esRechazado() -> OK
59. Evento.obtenerEstadoActual() -> OK
60. CambioEstado.esEstadoActual() -> OK
61. Gestor.calcularFechaHoraActual() -> OK
62. Evento.setEstadoActual(Estado) -> OK
63. Evento.rechazar(Estado, CambioEstado, fecha, usuario) -> OK
64. CambioEstado.setFechaHoraFin() -> OK
65. CambioEstado.setResponsableInspeccion() -> OK
66. new CambioEstado() -> OK

FASE 9: FINALIZACIÓN
67. Pantalla.finCU() -> OK

RESUMEN ESTADÍSTICO
- Coincidencias exactas: 62 (~92.5%)
- Diferencias menores (nombres): 5 (~7.5%)
- Métodos faltantes: 0
- Total mensajes comparados: 67

DIFERENCIAS DETECTADAS
- esAmbito() vs esAmbitoEventoSismico() (Estado): El código es más específico. Recomendación: alinear nombres según convención adoptada.
- buscarDatosSeriePorEstacion() (diag) vs buscarDatosSeriesPorEstacion() (código): singular vs plural.
- mostrarDatosEventoSismico() (diag) vs mostrarDatosEventosSismicos() (código): singular vs plural.
- opRecharEvento() (diag) vs opRechazarEvento() (código): error tipográfico en diagrama.

FORTALEZAS
- Fuerte adherencia al diagrama (flujo, mensajes y actores).
- Máquina de estados implementada correctamente en EventoSismico.
- Historial de estados con CambioEstado y trazabilidad (responsable, fecha fin).
- Separación de capas (Boundary/Control/Entity) consistente.

OPORTUNIDADES DE MEJORA
- Unificar nomenclatura diagrama↔código para evitar confusión.
- Reemplazar bubble sort por sorted() nativo para eficiencia.
- Mejorar validaciones (rangos/formatos) más allá de None.
- Desacoplar mocks (data.py) mediante repositorios/inyección de dependencias.
- Sustituir prints por logging estructurado.

CONCLUSIÓN GENERAL
La implementación es fiel al diagrama de secuencia con coincidencia casi total. Las diferencias son nominales y no afectan la funcionalidad. El diseño de la máquina de estados y las colaboraciones entre capas están correctamente realizadas. Calificación: 9.5/10.
